Static Block in Java

    A static block in a program is a set of statements which are executed by the JVM 
    (Java Virtual Machine) before the main method. At the time of class loading, 
    if we want to perform any task we can define that task inside the static block, 
    this task will be executed at the time of class loading. In a class, any number of a
    static block can be defined, and this static blocks will be executed from top to bottom




static and initializer block
    We can have both static and initializer blocks in a Java program. 
    But static block will execute first even before initializer block. 
   



Java uses Pass by Value (Call by Value)
    https://www.geeksforgeeks.org/g-fact-31-java-is-strictly-pass-by-value/
    


Java Lambda Expression

    The Lambda expression is used to provide the implementation of an interface which has functional
     interface. It saves a lot of code. In case of lambda expression, we don't need to define the 
     method again for providing the implementation. Here, we just write the implementation code.

    Java lambda expression is treated as a function, so compiler does not create .class file.


Functional Interface
    Lambda expression provides implementation of functional interface. An interface which has only 
    one abstract method is called functional interface. Java provides an anotation
    @FunctionalInterface, which is used to declare an interface as functional interface.


Why use Lambda Expression
    1)To provide the implementation of Functional interface.
    2)Less coding.

*******************************************************************************************************


Without Lambda Expression  (ANANYMOUS CLASS)
==========================================================
    interface Drawable{  
        public void draw();  
    }  
    public class LambdaExpressionExample {  
        public static void main(String[] args) {  
            int width=10;  
    
            //without lambda, Drawable implementation using anonymous class  
            Drawable d=new Drawable(){  
                public void draw(){System.out.println("Drawing "+width);}  
            };  
            d.draw();  
        }  
    }  




    @FunctionalInterface  //It is optional  
    interface Drawable{  
        public void draw();  
    }  
    
    public class LambdaExpressionExample2 {  
        public static void main(String[] args) {  
            int width=10;  

            //with lambda  
            Drawable d2=()->{  
                System.out.println("Drawing "+width);  
            };  
            d2.draw();  // calling draw method 

        }  
    }  


======================

Java Lambda Expression Example: Foreach Loop

    import java.util.*;  
    public class LambdaExpressionExample7{  
        public static void main(String[] args) {  
            
            List<String> list=new ArrayList<String>();  
            list.add("ankit");  
            list.add("mayank");  
            list.add("irfan");  
            list.add("jai");  
            
            list.forEach(  
                     (n)->System.out.println(n)  
                );  
        }  
    }  


***************************************************************

Java Lambda Expression Example: Comparator

    import java.util.ArrayList;  
    import java.util.Collections;  
    import java.util.List;  
    class Product{  
        int id;  
        String name;  
        float price;  
        public Product(int id, String name, float price) {  
            super();  
            this.id = id;  
            this.name = name;  
            this.price = price;  
        }  
    }  
    public class LambdaExpressionExample10{  
        public static void main(String[] args) {  
            List<Product> list=new ArrayList<Product>();  
            
            //Adding Products  
            list.add(new Product(1,"HP Laptop",25000f));  
            list.add(new Product(3,"Keyboard",300f));  
            list.add(new Product(2,"Dell Mouse",150f));  
            
            System.out.println("Sorting on the basis of name...");  
    
            // implementing lambda expression  
            Collections.sort(list,(p1,p2)->{  
                     return p1.name.compareTo(p2.name);  
            });  

            for(Product p:list){  
                System.out.println(p.id+" "+p.name+" "+p.price);  
            }  
    
        }  
    }  

===================================================================================

comparable vs Comparator


    To summarize, if sorting of objects needs to be based on natural order then use Comparable whereas 
    if you sorting needs to be done on attributes of different objects, then use Comparator in Java.


================
Comparable
=================
As the name suggests, Comparable is an interface defining a strategy of comparing an object with 
other objects of the same type. This is called the class's “natural ordering”.

Accordingly, in order to be able to sort – we must define our Player object as comparable by 
implementing the Comparable interface:

public class Player implements Comparable<Player> {

    // same as before

    @Override
    public int compareTo(Player otherPlayer) {
        return Integer.compare(getRanking(), otherPlayer.getRanking());
    }

}
==================================

Comparator

    The Comparator interface defines a compare(arg1, arg2) method with two arguments that represent 
    compared objects and works similarly to the Comparable.compareTo() method









Comparator vs Comparable
=============================
The Comparable interface is a good choice when used for defining the default ordering or, in other words, if it's the main way of comparing objects.

    Then, we must ask ourselves why use a Comparator if we already have Comparable?

    There are several reasons why:

    Sometimes, we can't modify the source code of the class whose objects we want to sort, thus making the use of Comparable impossible
    Using Comparators allows us to avoid adding additional code to our domain classes
    We can define multiple different comparison strategies which isn't possible when using Comparable







































